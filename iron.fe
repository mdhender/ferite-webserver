#! /usr/bin/env ferite

uses "console", "network", "regexp", "sys", "posix", "reflection", "regexp";

class HttpRequestHandler {
	function callback (object<HttpServerRequest> req) {}
}

class HttpServerRequest {
	string request;
	string buffer;
	array headers;
	object socket;
	object<HttpRequestHandler> handler;
	
	function handleSocket () {
		while (!self.socket.eos()) {
			string txt = self.socket.readln();
			self.buffer += txt;
		}
		if (Regexp.match("\n\\s*\n",self.buffer)) {
			array lines = Regexp.split("\r*\n",self.buffer);
			
			self.request = lines[0];
			
			lines[1..].each() using (h) {
				if (h != '') {
					array header_fragments = Regexp.split('\s*:\s*',h);
					if (header_fragments.size() > 1) {
						self.headers[header_fragments[0]] = header_fragments[1..].join(':');
					}
				}
			};
			
			self.handler.callback(self);
		}
	}
}

class MyServer extends HttpRequestHandler {
	function callback (object req) {
		array res = [
			'HTTP/1.0 200 OK',
			'Content-Type: text/html',
			'Content-Length: 56',
			'',
			'<html><body><h1>OK</h1>seems to be working</body></html>'
		];

		Console.println(req.request);
		req.headers.keys().each() using(key) {
			Console.println(key + ' -> ' + req.headers[key]);
		};
		
		req.socket.print(res.join("\n"));
		req.socket.flush();
		
		descriptors.del(descriptors.find(req.socket));
		requests.del(getKey(req.socket));
		
		req.socket.close();
		// Console.println('END OF CALLBACK ############################');
	}
}

function getKey (object con) {
	return '' + con.getDescriptor();
}

function addHttpListener (object con, object listener) {
	object httpservice = new HttpServerRequest();
	
	con.nonblock();
	httpservice.socket = con;
	httpservice.handler = listener;
	requests[getKey(con)] = httpservice;
}

function addSelectDescriptor (object con) {
	descriptors.push(con);
}

function acceptConnection (object con,object listener) {
	object client_connection = con.accept();
	string key = getKey(client_connection);
	addHttpListener(client_connection,listener);
	addSelectDescriptor(client_connection);
}

function keyCheck (array a, string k) {
	Console.println('KEY---> ' + k);
	Console.println('ARRAY:');
	Console.println(a.join("\n"));
	return a[k];
}

function handleIncomingData (object con) {
	string key = getKey(con);
	if (keyCheck(requests,key)) {
		requests[key].handleSocket();
	}
	Console.println('end of handleIncomingData');
}

global {
	object sock;
	array descriptors;
	array requests;
}

sock = Network.TCP.bind(Network.ANY,9090);

if (sock != null) {
	object<MyServer> my_server = new MyServer(); 
	descriptors = [ sock ];

	while (1) {
		object select_result = Posix.select(descriptors,[],[],1);
		
		if (select_result != null && select_result.read.size() > 0) {
			select_result.read.each() using(con) {
				if (con == sock) {
					acceptConnection(con,my_server);
				}
				else {
					handleIncomingData(con);
				}
			};
		}
	}
}
