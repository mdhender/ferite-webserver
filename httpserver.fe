uses 'regexp', 'sys', 'date', './tcpserver';

class HttpServerRequest extends TcpServerRequest {
	array request;
	array headers;
	array query;
	private string httpDateFormat = '%a, %d %b %Y %H:%M:%S %z GMT';
	private object content_handler;
	
	function parseHeaders (array lines) {
		array headers;
		// Note: Header names are converted to lower case for consistency
		
		lines.each() using (h) {
			array header_fragments = Regexp.split('\s*:\s*',h);
			if (header_fragments.size() > 1) {
				string key = header_fragments[0];
				string lowercase_key = key.toLower();
				string underscore_key = Regexp.replace('-',lowercase_key,'_');
				string value_text = header_fragments[1..].join(':');
				void value;
				
				// Automatic conversion for numerical values:
				if (value_text.isNumber()) value = value_text.toNumber();
				else                       value = value_text;
				
				headers[key] = value;
				headers[lowercase_key] = value;
				headers[underscore_key] = value;
			}
		};
		
		return headers;
	}
	
	function timestamp () {
		return Date.date(Date.GMTnow()).format(.httpDateFormat);
	}

	function parseRequestCommand (string request_text) {
		array r = Regexp.split('\s+',request_text);
		if (r.size() == 3) {
			array c = [
				'text' => request_text,
				'method' => r[0],
				'fullpath' => r[1],
				'proto' => r[2]
			];
			array q = Regexp.split('\?',c.fullpath);
			c['path'] = q[0];
			if (q.size() > 1) {
				c['query_string'] = q[1];
			}
			else {
				c['query_string'] = '';
			}
		}
		else {
			Sys.error('Invalid HTTP request',1);
		}
		return c;
	}

	function parseQueryString (string query_text) {
		array q;
		(Regexp.split('&',query_text)).each() using (p) {
			array r = Regexp.split('=',p);
			if (r.size() == 2) {
				q[r[0]] = r[1];
			}
			else {
				Sys.error('Invalid query format', 3);
			}
		};
		return q;
	}
	
	private function cleanup () {
		.headers = [];
		.request = [];
		.query = [];
	}
	
	private function processContentLength () {
		number buffer_length = .buffer.length();
		number content_length = .headers.content_length;
		
		if (buffer_length >= content_length) {
			string content;
			
			if (buffer_length > content_length) {
				content = .buffer[.. content_length];
				.buffer = .buffer[content_length+1 ..];
			}
			else {
				content = .buffer;
				.buffer = '';
			}
			.content_handler.invoke(self,content);
			.cleanup();
		}
	}
	
	private function processChunked () {
	
	}
	
	private function processPOST () {
		if (.content_handler) {
			array h = .headers;
			
			if (h['content_length'] != null) {
				if (h.content_length > 0)
					.processContentLength();
			}
			else if (h['transfer_encoding'] != null) {
				if (h.transfer_encoding == 'chunked')
					.processChunked();
			}
		}
	}
	
	private function parseHttp () {
		if (!.request) {
			object m = Regexp.match("\n\\s*\n",.buffer);
			if (m) {
				string header_text = .buffer[.. m.start()-1];
				array lines = Regexp.split("\r*\n",header_text);
				if (m.end() < .buffer.length()) {
					.buffer = .buffer[m.end() ..];
				}
				else {
					.buffer = '';
				}
			
				.request = .parseRequestCommand(lines[0]);
				.query = .parseQueryString(.request.query_string);
				.headers = .parseHeaders(lines[1..]);
			
				.handler.invoke(self);
			}
		}
		
		// Not using else because we may need to process
		// this after invoking the handler callback.
		
		if (.request) {
			if (.request.method == 'POST') {
				.processPOST();
			}
			else {
				// Only POST has content so cleanup request if not POST:
				.cleanup();
			}
		}
	}
	
	function onPostData () {
		object handler = recipient();
		if (handler) {
			.content_handler = handler;
		}
	}
	
	function hasContent () {
		if (.content_handler) return true;
		else                  return false;
	}
	
	function query (string key) {
		return .query[key];
	}
	
	function handleRequest () {
		.fillBuffer();
		.parseHttp();
	}
}

class HttpServer extends TcpServer {
	function createRequestObject () {
		return new HttpServerRequest();
	}
}
